{"/concepts/init":{"title":"搭建 threejs 的环境","data":{"":"今天我们来介绍下，怎么准备 threejs 的环境.","通过-html-引入#通过 html 引入":"创建一个 index.html 文件。我们可以通过引入 threejs 的 cdn 来引入 threejs 的库，在引入的时候我们使用 importmap 来引入，这样我们就可以使用 es6 的模块化来引入 threejs 了。\n<!DOCTYPE html>\n<html lang=\"en\">\n<body>\n<script type=\"importmap\">\n{\n\"imports\": {\n\"three\": \"https://cdn.jsdelivr.net/npm/three@0.170.0/build/three.module.min.js\"\nscript   }\n</script>\n<script type=\"module\">\nimport * as THREE from \"three\";\nconsole.log(THREE);\n</script>\n</body>\n</html>\n注意上 script 词，分别是第 6 行的 importmap 和第 10 行的 module，这两个关键词是 es6 的模块化的关键词，importmap 是用来引入第三方库的，module 是用来引入 es6 模块的。这里还有一个注意的地方，我们运行这个文件，不能直接双击打开这个 index.html,因为浏览器会报错，我们需要通过一个服务器来运行这个文件，我们可以通过安装一个 live-server 来运行这个文件。用 vscode 的话可以直接安装一个插件 live server，然后右键点击 index.html 选择 open with live server 就可以运行了。\n\n安装好了这个插件之后，我们可以直接右键点击 index.html 选择 open with live server 就可以运行了。\n或者通过右下角的 Go Live 按钮来运行。\n\n\n\n点击运行成功后，可以看到服务启动的端口号，然后我们可以在浏览器中输入这个端口号来访问我们的页面。\n\n\n\n在浏览器中访问 http://localhost:5500 就可以看到我们的页面了。\n\n\n\n同时看到控制台中输出了 THREE 对象，说明我们引入成功了。上面我们用了 importmap 来引入 threejs，我们也可以不使用它，直接通过 script 标签引入 threejs。\nimport * as THREE from \"https://cdn.jsdelivr.net/npm/three@0.170.0/build/three.module.min.js\";\n毫无疑问，这种的代码的可读性没有上面优雅。对于直接请求在线的资源，实际上我们也可以将这个文件下载下来，然后使用相对路径进行引入。以上，就是通过 html 引入 threejs 的方式。vite 是一个基于 esmodules 的开发服务器，它可以让我们在开发的时候使用 es6 的模块化来开发，同时它还支持热更新。\n使用它很方便搭建一个纯 js，或者 vue，react 的项目。\n官方文档：https://vitejs.cn/vite3-cn/guide/","安装-vite#安装 vite":"npm create vite\n对于原生 js 的项目，我们可以选择 vanilla。\n\n\n\n接着我们安装 threejs。\nnpm install three\n有时候，我们会遇到网络问题，依赖一直下载不下来，可以通过国内源来下载。\nnpm install three --registry=https://registry.npmmirror.com\n然后我们可以在 src/main.js 中引入 threejs。\n\n\n\nimport * as THREE from \"three\";\nconsole.log(THREE);\n接着我们运行项目。\nnpm run dev\n同样，我们在浏览器中访问 http://localhost:5173 就可以看到控制台输出了 THREE 对象\n\n\n如果开发一个正式一点的项目，还是建议使用 vite 来搭建项目。只是想运行一个简单的案例，熟悉下某个 API，那么可以直接通过 html 来引入 threejs。"}},"/concepts/box":{"title":"第一个案例：创建一个立方体","data":{"":"今天会用一个例子，带大家来一起走一遍 Threejs 最基础的功能，我们会建一个方盒子。通过这个例子，你会学到如何\n创建一个场景\n如何创建一个相机\n如何创建一个渲染器\n如何创建一个立方体\n如何将立方体添加到场景中\n\n先来看下最后完成的效果如下\n\n\n\n关于怎么创建项目， 可以看上一篇文章，链接。这里我们使用 vite 来创建项目。在写代码之前，我们来了解一些 3D 的概念。","什么是场景#什么是场景":"场景可以理解成一个容器，里面可以放置很多物体，比如立方体、球体、光源等。场景是所有 3D 元素的容器，所有的 3D 元素都是放在场景中的。在 Threejs 以及其他 3D 引擎中，场景是一个很重要的概念。在我们开始添加物体之前，我们需要先创建一个场景。很多时候，如果你想添加的物体没有在场景中显示，那么可以检查一下是不是没有将物体添加到场景中。","为什么需要相机#为什么需要相机":"有了场景了，相当于有了我们的世界，但是我们还需要一样东西，去观察这个世界，这个东西就是相机。相机是用来观察场景的，如果没有相机，我们是看不到场景的。所以相机相当于我们的眼睛，我们可以通过相机的位置、视角等属性来观察场景。我们通过相机来观察场景，通过操作相机，通过一系列的操作，比如移动相机、旋转相机来展示我们想要的场景。","什么是渲染器#什么是渲染器":"Three.js 的渲染器是用来把 3D 场景显示到网页上的工具。它的作用就像一个画家，把场景里的物体按照摄像机的角度“画”到屏幕上。最常用的是 WebGLRenderer，它利用浏览器的 WebGL 技术，让画面更快更真实。你可以通过设置渲染器，比如分辨率、是否需要平滑边缘（抗锯齿），来调整画面的效果和流畅度。简单来说，渲染器就是 Three.js 的“画笔”，帮你把 3D 世界变成能看的画面。","渲染器和相机的关系#渲染器和相机的关系":"在 Three.js 中，渲染器和相机的关系非常重要。它们共同决定了 3D 场景是如何被显示到屏幕上的：相机就像人的眼睛，决定了你从哪个角度、位置和范围去看这个 3D 场景。渲染器负责把相机“看到”的内容画到屏幕上。它会根据场景、相机的位置和角度，计算出每个物体的外观，然后显示成一个 2D 图像。相机决定“看什么”（场景中的哪些物体、从什么角度看）。渲染器决定“怎么画”（把相机看到的东西显示在屏幕上）。通俗地说，相机是“眼睛”，渲染器是“画手”，它们一起完成了从 3D 场景到屏幕图像的过程。没有相机，渲染器不知道该画什么；没有渲染器，相机看到的东西无法展示出来。好了，到此为止，我们科普了一些最基础的概念。下面我们来看看如何通过代码来实现一个 3D 方盒子。在 main.js 中引入 three.js\nimport * as THREE from \"three\";","创建场景#创建场景":"首先，我们需要创建一个场景：\nconst scene = new THREE.Scene();","创建相机#创建相机":"接下来，我们创建一个透视相机：\nconst camera = new THREE.PerspectiveCamera(\n75,\nwindow.innerWidth / window.innerHeight,\n0.1,\n1000\n);\ncamera.position.z = 5;\n上面的代码含义是，创建一个透视相机，视角是 75 度，宽高比是窗口的宽高比，视锥体的近端是 0.1，远端是 1000。然后将相机的 z 坐标设置为 5，这样相机就在 z 轴上离场景 5 个单位的位置。\n\n\n我们用一张图来理解，上面的绿色部分就是近端，蓝色部分就是远端，中间红色的球体部分就是相机的可视区域，对于最右侧的灰色的球体，相机是看不到的。所以我们在设计相机数值，以及摆放我们物体的时候，都要考虑到这个可视区域。视角毫无疑问，当视角越大，我们看到的东西就越多。","创建画布元素#创建画布元素":"现在，我们已经有了场景和相机，接下来我们需要一个画布元素来显示场景。我们可以通过创建一个 canvas 元素并将其添加到文档中来实现：\nconst canvas = document.createElement(\"canvas\");\ndocument.body.appendChild(canvas);","创建渲染器#创建渲染器":"接下来，我们创建一个 WebGL 渲染器，并设置其大小：\nconst renderer = new THREE.WebGLRenderer({ canvas });\nrenderer.setSize(window.innerWidth, window.innerHeight);","处理窗口大小调整#处理窗口大小调整":"对于上面的代码，一旦我们调整窗口大小，画布的大小就不会改变，所以我们需要在窗口大小调整时更新渲染器和相机。为了在窗口大小调整时更新渲染器和相机，我们添加一个事件监听器 resize，如下所示：\nwindow.addEventListener(\"resize\", () => {\nrenderer.setSize(window.innerWidth, window.innerHeight);\ncamera.aspect = window.innerWidth / window.innerHeight;\ncamera.updateProjectionMatrix();\n});\n这段代码就是说，当我们调整窗口大小的时候，我们需要重新设置渲染器的大小，然后重新设置相机的宽高比，最后更新相机的投影矩阵。\n这里设置的大小就是浏览器的大小，也就是 window.innerWidth 和 window.innerHeight。","创建几何体#创建几何体":"到此为止，我们已经有了基础的东西了，接下来开始上我们的主角。我们创建一个立方体的几何体：\nconst geometry = new THREE.BoxGeometry();","创建材质#创建材质":"有了立方体，但是它是没有颜色的，我们需要给它添加一个材质，这样它才能有颜色。我们创建一个基本材质，并设置其颜色为绿色，这里的颜色使用十六进制表示：\nconst material = new THREE.MeshBasicMaterial({ color: 0x00ff00 });","创建网格#创建网格":"在 Three.js 中，网格（Mesh） 是用于渲染场景中可见对象的一个核心概念。它是一个容器对象，将三维物体的几何形状（Geometry）和其表面的材质（Material） 结合在一起，创建一个可渲染的对象。","网格的构成#网格的构成：":"几何体（Geometry）：定义了物体的形状，例如球体、立方体、平面等。\n材质（Material）：定义了物体的外观，包括颜色、光泽、纹理等。","网格的作用#网格的作用":"呈现三维物体\n网格是场景中可见物体的基础。通过网格，将几何体和材质绑定在一起，可以在场景中渲染出各种形状和外观的三维物体。\n管理物体的行为\n网格提供了位置、旋转、缩放等属性，可以控制物体在场景中的显示位置、朝向和大小：\n位置（position）：指定网格在三维空间中的位置。\n旋转（rotation）：设置网格的旋转角度。\n缩放（scale）：调整网格的大小。\n\n\n与光线交互\n当使用支持光照的材质时（如 MeshStandardMaterial），网格会响应场景中的光照变化，使得物体看起来更加真实。\n组合复杂对象\n通过将多个网格组合在一起，可以创建复杂的物体。例如，一个机器人模型可以由多个部件（头、手、脚）组成，每个部件是一个独立的网格。\n实现动画和交互\n网格对象可以结合 Three.js 的动画功能（如 Object3D 的更新），实现动态效果，例如旋转的立方体、跳动的球等。此外，网格还可以用于响应用户交互（如鼠标点击或拖拽）。\n\n可以把网格想象成一件衣服：\n几何体（Geometry） 是衣服的版型或剪裁，决定衣服的形状。\n材质（Material） 是衣服的颜色、质地，决定衣服看起来是红色丝绸还是黑色棉布。\n网格（Mesh） 则是穿好衣服的成品，真正展示在场景中的对象。然后，我们将几何体和材质组合成一个网格，并将其添加到场景中：\nconst cube = new THREE.Mesh(geometry, material);\nscene.add(cube);\n网格是一个重要的概念，在 Three.js 中，网格是由几何体和材质组成的。几何体定义了网格的形状，材质定义了网格的外观。","渲染#渲染":"通过上面的代码，我们已经有了场景，相机，渲染器，立方体，接下来我们需要渲染场景，将所有的东西显示到屏幕上：\nrenderer.render(scene, camera);\n到此为止，我们可以在界面上看一个绿色不动的立方体了。","动画循环#动画循环":"在说动画之前，我们先简单了解下动画的一些概念。动画其实就是让东西动起来的过程，通过快速连续显示一系列略有不同的静态画面来模拟物体运动的效果。比如，一个小球从左边滚到右边，这就是动画。为了实现这个效果，我们需要不断改变小球的位置，让它一点一点地移动，看起来就像在滚动一样。在 Three.js 中，动画就是通过不停地更新物体的各种属性（比如位置、大小、角度等），然后把这些变化显示在屏幕上，从而让人觉得它们在动。","动画的基本要素#动画的基本要素":"时间：\n动画本质上是随时间变化的视觉效果。时间在动画中起到决定性作用，控制着变化的速度和节奏。\n在 Three.js 中，通常通过每帧的时间间隔 (delta time) 来平滑地更新动画。\n\n\n关键帧 (Keyframes)：\n关键帧是描述动画中某一特定时间点状态的数据集合。\n通过插值算法计算关键帧之间的过渡效果（称为补间），使动画更流畅。\n\n\n插值 (Interpolation)：\n动画系统通过插值算法计算关键帧之间的变化。例如，从位置 (0, 0, 0) 平滑移动到位置 (10, 10, 10)。\n常用插值方式包括线性插值（线性变化）和缓动插值（如加速或减速效果）。\n\n\n帧率 (Frame Rate)：\n帧率是动画每秒渲染的帧数（FPS）。高帧率能带来更流畅的动画体验，Three.js 默认帧率由 requestAnimationFrame 控制，与浏览器刷新率一致（通常为 60 FPS）。\n\n\n\n通俗一点理解就是我们每次变化一次物体的属性（位置，属性等），然后拍一次照，将这些照片连续播放，就是动画了。通常，我们会使用 requestAnimationFrame 函数来创建一个动画循环，这样可以确保动画在浏览器的每一帧都会更新。\nfunction animate() {\nrequestAnimationFrame(animate);\ncube.rotation.x += 0.01;\ncube.rotation.y += 0.01;\nrenderer.render(scene, camera);\n}\nanimate();\n上面的代码中，我们调用第一次调用 animate 函数，然后在 animate 函数中，我们调用 requestAnimationFrame 函数。requestAnimationFrame 函数会在浏览器下一次重绘之前调用回调函数，大概是每秒 60 次。也就是 1/60 秒调用一次 animate 函数。然后，每次执行 animate 函数的时候，我们都会让立方体绕 x 和 y 轴旋转 0.01 弧度。最后执行 renderer.render(scene, camera) 函数，将变化后的场景渲染到屏幕上。现在，你已经完成了一个简单的 Three.js 场景设置，并且可以看到一个旋转的绿色立方体！\n\n\n\nimport * as THREE from \"three\";\n\nconst scene = new THREE.Scene();\n\nconst camera = new THREE.PerspectiveCamera(\n75,\nwindow.innerWidth / window.innerHeight,\n0.1,\n1000\n);\ncamera.position.z = 5;\n\nconst canvas = document.createElement(\"canvas\");\ndocument.body.appendChild(canvas);\n\nconst renderer = new THREE.WebGLRenderer({ canvas });\nrenderer.setSize(window.innerWidth, window.innerHeight);\n\nwindow.addEventListener(\"resize\", () => {\nrenderer.setSize(window.innerWidth, window.innerHeight);\ncamera.aspect = window.innerWidth / window.innerHeight;\ncamera.updateProjectionMatrix();\n});\n\nconst geometry = new THREE.BoxGeometry();\n\nconst material = new THREE.MeshBasicMaterial({ color: 0x00ff00 });\n\nconst cube = new THREE.Mesh(geometry, material);\n\nscene.add(cube);\n\nfunction animate() {\nrequestAnimationFrame(animate);\n\ncube.rotation.x += 0.01;\n\ncube.rotation.y += 0.01;\n\nrenderer.render(scene, camera);\n}\n\nanimate();"}},"/concepts/introduce":{"title":"什么是web图形学","data":{"":"最近在学图形学的东西，感觉打开了一个新世界。这几年的前端工作给我的一个感受就是，做着前端的东西，但是好像离前端很远。图形学虽然在浏览器上显示内容，但是实际上它是一个独立的领域，它有自己的理论和技术，这些技术和前端的技术有很多的交集，但是也有很多的不同。如果一开始钻入图形学的话，可能会有很多的概念和技术需要学习，这样可能会让人望而生畏。但是如果一开始我们学习 Three.js 的话，可能会让我们的学习更加的轻松。它是一个基于 WebGL 的 3D JavaScript 库，它使你可以在浏览器中创建 3D 图形。使用它可以实现很多的效果，而且实现起来也不是很复杂。等打好了兴趣，再去学习图形学的理论知识，可能会更加的轻松。本系列的教程是基于 Three.js 的 0.170.0 版本，所以文章后面的案例代码都是基于这个版本的。\n关于 170 可以的版本可以访问 fork 仓库 https://github.com/calmound/three.js-170\n官方文档\nhttps://threejs.org/docs/index.html#manual/zh/introduction/Creating-a-scene\n目前官方文档也有中文版\n![[./image/1.png]]\n而且他也有丰富的案例\n![[./image/2.png]]\n\n对于这个项目，我们也可以本地去执行，进入他的代码仓库或者我上面的 fork 仓库，然后执行,进行 git clone\ngit clone https://github.com/calmound/three.js-170.git\n之后执行\nnpm install\nnpm run dev\n启动服务后，我们访问 http://localhost:8080 就可以看到官方的文档了\n![[./image/1.png]]\n之后，我们打开项目，查看 examples 文件夹，里面有很多的案例，我们可以通过这些案例来学习 Three.js\n\n\n大家也可以看 url 的最后的路径名称，其实就是对应的案例文件的名字。\n\n\n通过官网的案例大家可以找到自己想要的案例，然后去看源码，这样会更加的直观。\nhttps://discoverthreejs.com/book/introduction/\n这是一个关于 threejs 入门的书籍，他不是简简单单就用文字描述，每个章节都从有对应的案例。这个网站是交互式的，跟着他的介绍一边看一边写代码。\n通过这个网站，首先减少了我们前期搭建环境的时间，而且他还有正确的代码对比。\n\n比如，\n\n\n上面图是其中的一个章节，他的页面分为三个部分，左侧是教程，右侧上班区域是代码编辑区，右侧下半部分是预览区域。在右侧写入的代码，可以实时的在下半部分看到效果。当我店家，左上角的按钮之后，能够显出出完整的正确的代码，这样很容易一目了然，看到自己的代码和正确的代码的区别。\n\n官网的案例比较适合当作字典查漏补缺，它配合官网的 API，有助于我们对于 API 的理解。但是第二个网站对于入门来说更加友好，更加容易上手。"}},"/examples/star":{"title":"太阳系网站","data":{"":"","介绍#介绍":"今天，使用 threejs 实现一个简单的网站，是结合 threejs 的一个项目。先看一下效果","项目初始化#项目初始化":"使用 vite 进行项目初始化，可以用 npm 进行创建项目，也可以使用 pnpm 进行创建项目，这里使用 pnpm 进行创建项目。\npnpm create vite\n执行命令后，下面的选项根据这张图进行勾选。","安装项目依赖#安装项目依赖":"这里注意要用下面我的案例的版本，随着时间 threejs 会进行更新，到时候可能很多 api 会有变化，为了降低学习成本，建议使用我这个版本。这样文章下面的代码肯定是能运行的。\npnpm install three@0.169.0","启动项目#启动项目":"pnpm dev","开发#开发":"打开 main.js, 将里面的代码都删了，然后写入下面的代码。\nimport * as THREE from 'three';\n\nconsole.log(THREE);\n打开 f12，查看控制台 console，如果输出了 THREE 对象，说明安装成功。","搭建静态页面#搭建静态页面":"打开项目的 html 文件，然后写入我们的三个区块\n<canvas id=\"canvas\"></canvas>\n<section class=\"section\">\n<h2>太阳</h2>\n</section>\n<section class=\"section\">\n<h2>地球</h2>\n</section>\n<section class=\"section\">\n<h2>月球</h2>\n</section>\n然后在 css 文件中写入样式，我们设置每块都占满屏幕。为后续的布局做准备。\n#canvas {\nposition: fixed;\ntop: 0;\nleft: 0;\n}\n\n.box {\ndisplay: flex;\nalign-items: center;\nheight: 100vh;\nfont-size: 48px;\npadding-left: 20%;\n}\n\n/*  奇数在右边 */\n.box:nth-child(odd) {\njustify-content: flex-end;\npadding-right: 10%;\n}\n最后在 main.js 中引入 css 文件\nimport './style.css';","创建场景#创建场景":"import * as THREE from 'three';\nimport './style.css';\n\nconst canvas = document.getElementById('canvas');\n// 创建场景\nconst scene = new THREE.Scene();\n\n// 创建相机\nconst camera = new THREE.PerspectiveCamera(\n35,\nwindow.innerWidth / window.innerHeight,\n0.1,\n100\n);\ncamera.position.set(0, 0, 10); // 设置相机位置\nscene.add(camera); // 将相机添加到场景中\n\n// 创建渲染器\nconst renderder = new THREE.WebGLRenderer({\ncanvas,\n});\nrenderder.setClearAlpha(0); // 设置透明背景\nrenderder.setSize(window.innerWidth, window.innerHeight); // 设置渲染器的大小\n\n// 创建立方体\nconst geometry = new THREE.BoxGeometry(1, 1, 1);\nconst material = new THREE.MeshBasicMaterial({ color: 0x00ff00 });\nconst cube = new THREE.Mesh(geometry, material);\ncube.position.set(0, 0, 0); // 设置立方体位置\nscene.add(cube);\n\n// 渲染\nrenderder.render(scene, camera);\n\n\n\n现在可以在页面看到一个绿色的立方体，代表你已经成功创建了一个 three 的场景。","创建星球#创建星球":"通过 THREE.SphereGeometry 创建一个球体\n通过 THREE.MeshBasicMaterial 创建一个材质\n通过 THREE.TextureLoader 创建引入星球的贴图\n通过 THREE.Mesh 创建一个星球\n\n\n// 太阳\nconst distance = 1;\nconst sun = new THREE.Mesh(\nnew THREE.SphereGeometry(1.2),\nnew THREE.MeshStandardMaterial({\nmap: textLoader.load('img/sun_bg.jpg'),\n})\n);\nsun.position.set(1.5, distance * 0, 0); // 设置立方体位置\nscene.add(sun);\n\n// 地球\nconst earth = new THREE.Mesh(\nnew THREE.SphereGeometry(0.5),\nnew THREE.MeshStandardMaterial({\nmap: textLoader.load('img/earth_bg.jpg'),\n})\n);\nearth.position.set(1.5, -distance * 1, 0); // 设置立方体位置\nscene.add(earth);\n\n// 月球\nconst moon = new THREE.Mesh(\nnew THREE.SphereGeometry(0.2),\nnew THREE.MeshStandardMaterial({\nmap: textLoader.load('img/moon_bg.jpg'),\n})\n);\nmoon.position.set(1.5, -distance * 2, 0); // 设置立方体位置\nscene.add(moon);\n\nconst animate = () => {\nrenderder.render(scene, camera);\n\nrequestAnimationFrame(animate);\n};\nanimate();\n在这里，我们使用了 distance 变量来控制每个星球之间的距离，然后通过 position 来设置每个星球的位置。还有一个主意就是我们最后一定要，增加一个 animate 函数，这个函数会在每一帧都执行，因为我们的贴图是异步的，导致可能在贴图加载完成之前，就已经渲染了，导致看不到贴图，所以我们需要重新在渲染一次。至此，你在页面右侧应该可以看见三个球体。","滚动#滚动":"到此为止，我们已经在页面创建了星球了，但是现在所有的球体都在太阳这个区块里面。\n现在，我们需要让每个星球都在自己的区块里面，这样我们就可以看到每个星球了。所以，我们要做的事\n计算每个区块的位置，将每个星球的 position 的 y 坐标放到对应的区块中\n增加滚动事件，当我们滚动鼠标的时候，通过 camera.position.y 来控制相机的位置，当我们的相机向下移动，从视觉上看，就是星球在上升。threejs 的 y 坐标的数值和浏览器滚动的 scrolly 的数值是不相等的，所以我们需要进行换算。\n2.1 我们先设置 distance 的值为 4，然后将每个球体的间距设置为 distance，然后通过 distance _ i 来设置每个星球的位置。\n2.2 当我们进行滚动条滚动后，我们通过 -scrollY / window.innerHeight _ distance 将滚动条的数值转换成摄像机的 y 坐标。\n\n\nconst distance = 4;\n// 太阳\nconst sun = new THREE.Mesh(\nnew THREE.SphereGeometry(1.2),\nnew THREE.MeshStandardMaterial({\nmap: textLoader.load('img/sun_bg.jpg'),\n})\n);\nsun.position.set(1.5, distance * 0, 0); // 设置立方体位置\nscene.add(sun);\n\n// 地球\nconst earth = new THREE.Mesh(\nnew THREE.SphereGeometry(1.2),\nnew THREE.MeshStandardMaterial({\nmap: textLoader.load('img/earth_bg.jpg'),\n})\n);\nearth.position.set(-1.5, -distance * 1, 0); // 设置立方体位置\nscene.add(earth);\n\n// 月球\nconst moon = new THREE.Mesh(\nnew THREE.SphereGeometry(1.2),\nnew THREE.MeshStandardMaterial({\nmap: textLoader.load('img/moon_bg.jpg'),\n})\n);\n\nconst animate = () => {\nrenderder.render(scene, camera);\ncamera.position.y = (-scrollY / window.innerHeight) * distance;\nrenderder.render(scene, camera);\nrequestAnimationFrame(animate);\n};\n至此，我们可以让星球跟着浏览器进行滚动了","动画#动画":"现在的星球太死板了，我们需要让他们动起来，我们可以通过旋转来让他们动起来。在 animate 函数下，增加\nconst animate = () => {\ncamera.position.y = (-scrollY / window.innerHeight) * distance;\n\n// 星球旋转\nsun.rotation.y += 0.01;\nearth.rotation.y += 0.01;\nmoon.rotation.y += 0.01;\n\nrenderder.render(scene, camera);\n\nrequestAnimationFrame(animate);\n};\n\n\n然后，我们在进行优化，当鼠标在屏幕上移动的时候，我们让星球也进行一点抖动\n获取鼠标的位置\n\n\nlet mouse = {\nx: 0,\n};\nwindow.addEventListener('mousemove', (event) => {\nmouse = {\nx: event.clientX,\n};\n});\n\n计算鼠标的位置和星球的位置的差值\n让星球的位置加上差值, 因为差值特别大，所以我们需要乘以一个系数，这里我们乘以 0.5，然后我们在乘以 deltaTime（渲染的这帧和上一帧的时间差），这样我们就可以让星球的位置平滑的变化。\n\n\nconst clock = new THREE.Clock();\nlet oldElapsedTime = 0;\nconst animate = () => {\nconst elapsedTime = clock.getElapsedTime();\nconst deltaTime = elapsedTime - oldElapsedTime;\n\noldElapsedTime = elapsedTime;\nrenderder.render(scene, camera);\n\ncamera.position.y = (-scrollY / window.innerHeight) * distance;\n\nconst cursorX = mouse.x / window.innerWidth - 0.5;\n\nconst parallaxX = cursorX * 0.5;\n\ncamera.position.x += (parallaxX - camera.position.x) * 4 * deltaTime;\n\n// 星球旋转\nsun.rotation.y += 0.01;\nearth.rotation.y += 0.01;\nmoon.rotation.y += 0.01;\n\nrenderder.render(scene, camera);\n\nrequestAnimationFrame(animate);\n};\n这样当我们鼠标在屏幕上移动的时候，星球就会进行抖动了。","增加粒子#增加粒子":"现在画面太空，我们给背景增加一些粒子\nconst particlesCount = 5000;\nconst posArray = new Float32Array(particlesCount * 3);\n\nfor (let i = 0; i < particlesCount; i++) {\nposArray[i * 3] = (Math.random() - 0.5) * 5;\nposArray[i * 3 + 1] = distance * 0.5 - Math.random() * distance * stars.length\nposArray[i * 3 + 2] = (Math.random() - 0.5) * 5;\n}\nconst particlesGeometry = new THREE.BufferGeometry();\n\nparticlesGeometry.setAttribute('position', new THREE.BufferAttribute(posArray, 3));\nconst particlesMaterial = new THREE.PointsMaterial({\nsize: 0.005,\ncolor: 0xffffff,\nsetAttenuation: true // 设置衰减\n});\n\nconst particles = new THREE.Points(particlesGeometry, particlesMaterial);\nscene.add(particles);\n\n\n到此我们，整个页面算是开发完了，但是现在页面感觉还是太空。所以我们可以给标题下面在增加一些介绍。我们先改 html, 增加一个 text 的 div，增加描述文字\n<!-- html -->\n<div class=\"box\">\n<div>\n<h2>太阳</h2>\n<div class=\"text\">\n太阳是太阳系的中心，也是地球和其他行星的主要能量来源。作为一颗黄矮星，它通过核聚变反应，将氢转化为氦并释放出巨大的能量。太阳的光和热使地球能够维持生命，并影响整个太阳系的天气和气候。它占据了太阳系99.86%的总质量，其巨大的引力将所有行星、卫星、小行星和彗星维系在各自的轨道上。太阳的直径约为140万公里，距地球约1.5亿公里，光从太阳到达地球大约需要8分钟20秒。\n</div>\n</div>\n</div>\n\n<!-- css -->\n.text {\nfont-size: 20px;\nwidth: 600px;\n}\n\n最后，大家可以按照前面的星球然后将其他星球的内容补上，最后的效果如下"}},"/":{"title":"Three.js","data":{"":""}}}